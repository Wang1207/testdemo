#!/usr/bin/env bash
set -euo pipefail

DB_USER="hxbprod" # 数据库用户
DB_PASS="123456" # 数据库密码
DB_SID="SUMMIT" # 数据库 SID/服务名
SQL_FILE="" # SQL 文件路径
WORK_PATH="/sumapps/summit/backup/$(date '+%Y%m%d')" # 工作路径
DAEMON_MODE="false" # 是否守护进程模式
INTERNAL_RUN="false" # 内部执行标记

ORACLE_HOME_DEFAULT="/opt/oracle" # 默认 ORACLE_HOME
NLS_LANG_DEFAULT="AMERICAN_AMERICA.AL32UTF8" # 默认字符集

usage() { # 使用说明
  cat <<'USAGE'
Usage:
  oracle_runner.sh [-d|--daemon] [db_user] [db_pass] [db_sid] [sql_file] [work_path]

Options:
  -d, --daemon   Run in daemon mode (background).

Notes:
  - Unspecified parameters use defaults defined in the script.
  - sql_file should contain DML (insert/update/delete) for execution.
  - A generated SQL file (with global variables) will be written to work_path.
  - A CSV export will be produced from sql_file if it contains a SELECT.
USAGE
}

log() { # 日志输出
  local level="$1"
  shift
  printf '[%s] [%s] %s\n' "$(date '+%F %T')" "$level" "$*"
}

setup_oracle_env() { # 设置 Oracle 环境变量
  export ORACLE_HOME="${ORACLE_HOME:-$ORACLE_HOME_DEFAULT}"
  export NLS_LANG="${NLS_LANG:-$NLS_LANG_DEFAULT}"
  export PATH="$ORACLE_HOME/bin:$PATH"
  export LD_LIBRARY_PATH="$ORACLE_HOME/lib:${LD_LIBRARY_PATH:-}"
}

check_connection() { # 账号密码校验
  log INFO "Checking database connection for user: ${DB_USER}"
  sqlplus -s "${DB_USER}/${DB_PASS}@${DB_SID}" <<'SQL'
whenever sqlerror exit failure rollback
set heading off feedback off pagesize 0 verify off echo off
select 1 from dual;
exit;
SQL
}

generate_sql() { # 生成带全局变量的 SQL 文件
  local ts
  ts="$(date '+%Y%m%d%H%M%S')"
  GENERATED_SQL_FILE="${WORK_PATH}/generated_${DB_USER}_${ts}.sql"

  local app_schema="${DB_USER}"
  local run_date="$(date '+%F')"

  cat <<SQL > "${GENERATED_SQL_FILE}"
-- Generated SQL with global variables
-- app_schema: ${app_schema}
-- run_date: ${run_date}

insert into ${app_schema}.demo_table (id, created_at, note)
values (demo_seq.nextval, to_date('${run_date}','YYYY-MM-DD'), 'generated by script');

update ${app_schema}.demo_table
   set note = 'updated on ${run_date}'
 where note = 'generated by script';

-- End of generated SQL
SQL

  log INFO "Generated SQL file: ${GENERATED_SQL_FILE}"
}

run_dml() { # 执行 DML，失败回滚
  log INFO "Running DML from: ${SQL_FILE}"
  sqlplus -s "${DB_USER}/${DB_PASS}@${DB_SID}" <<SQL
whenever sqlerror exit failure rollback
set echo on feedback on timing on
@${SQL_FILE}
commit;
exit;
SQL
}

export_csv() { # 根据 SQL 导出 CSV（含表头）
  local csv_file
  csv_file="${WORK_PATH}/export_${DB_USER}_$(date '+%Y%m%d%H%M%S').csv"

  log INFO "Exporting data to CSV: ${csv_file}"
  sqlplus -s "${DB_USER}/${DB_PASS}@${DB_SID}" <<SQL
whenever sqlerror exit failure rollback
set heading on feedback off pagesize 0 verify off echo off
set markup csv on delimiter , quote off
spool ${csv_file}
@${SQL_FILE}
spool off
exit;
SQL
}

daemonize() { # 守护进程模式
  log INFO "Starting daemon mode"
  nohup "$0" --run "${DB_USER}" "${DB_PASS}" "${DB_SID}" "${SQL_FILE}" "${WORK_PATH}" \
    > /dev/null 2>&1 &
  log INFO "Daemon started with PID $!"
}

parse_args() { # 解析入参
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -d|--daemon)
        DAEMON_MODE="true"
        shift
        ;;
      --run)
        INTERNAL_RUN="true"
        shift
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      *)
        break
        ;;
    esac
  done

  if [[ $# -gt 5 ]]; then
    usage
    exit 1
  fi

  DB_USER="${1:-$DB_USER}"
  DB_PASS="${2:-$DB_PASS}"
  DB_SID="${3:-$DB_SID}"
  SQL_FILE="${4:-$SQL_FILE}"
  WORK_PATH="${5:-$WORK_PATH}"
}

run_main() { # 主流程
  mkdir -p "${WORK_PATH}"
  local ts
  ts="$(date '+%Y%m%d%H%M%S')"
  LOG_FILE="${WORK_PATH}/${DB_USER}_${ts}.log"

  exec > >(tee -a "${LOG_FILE}") 2>&1

  setup_oracle_env
  log INFO "Log file: ${LOG_FILE}"
  log INFO "Oracle SID: ${DB_SID}"
  log INFO "SQL file: ${SQL_FILE}"
  log INFO "Work path: ${WORK_PATH}"

  check_connection
  generate_sql
  run_dml
  export_csv

  log INFO "All operations completed successfully"
}

main() { # 入口
  parse_args "$@"

  if [[ "${DAEMON_MODE}" == "true" && "${INTERNAL_RUN}" == "false" ]]; then
    daemonize
    exit 0
  fi

  if [[ -z "${SQL_FILE}" ]]; then
    SQL_FILE="${WORK_PATH}/default_query.sql"
  fi

  if [[ ! -f "${SQL_FILE}" ]]; then
    mkdir -p "${WORK_PATH}"
    cat <<'SQL' > "${SQL_FILE}"
select count(1) from dmenv;
SQL
    log INFO "SQL file not found, created default: ${SQL_FILE}"
  fi

  run_main
}

main "$@"
